<!---
   Copyright (c) 2025 OpenHW Group

   Licensed under the Solderpad Hardware Licence, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

   https://solderpad.org/licenses/

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   SPDX-License-Identifier: Apache-2.0 WITH SHL-2.1
--->

# Spike
Spike is a RISC-V instruction set simulator (ISS), which means it simulates the _architectural_ affect of executing RISC-V instructions.
That is, as Spike executes each instruction it will update the value stored in the PC, all GPRs and CSRs, plus memory to match the intent of the RISC-V ISA.
Spike reads an [Executable and Linkable Format](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format) file which is generated by GCC and containts
(amoung other things) the machine code of the compiled-and-linked test-program.
This makes Spike extremely useful as teaching tool for understanding of how a particular program runs and to aid in the development of other software tools (e.g. the compiler) or even the development of new RISC-V instruction sets.
For our purposes, Spike is particularly useful in two ways:
1. For developing and debugging test-programs.
2. As a Reference Model that predicts the _architectual state_ (that is, the PC, all GPRs and CSRs, plus memory contents) after each instruction is executed.

Our primary interest in Spike is it's use as a Reference Model for RISC-V RTL implementations.
Nevertheless, it will be helpful to investigate the use of Spike as a simulator, as doing so informs much of the Reference Model use-case.

<!---
#### Spike as a Reference Model
Spike was the original reference model of the RISC-V instruction set architecture,
and is often used as a reference against which other RISC-V hardware or software implementations can be compared.
An ISS abstracts away clock cycle delays such as memory transactions, etc.
By definition, all instructions running on an ISS execute in a single instruction cycle,
while in phyical hardware or an RTL model, different instructions may consume one or more clock cycles.
--->

## Spike Programming Conventions
In the ideal case, Spike would be agnostic of any programming conventions and could therefore be readily suited to any usage model without restrictions.
Of course, we live in the real world and Spike has a number of programming conventions that need to be followed (unless you are willing to re-write the source code yourself).
For the most part, these conventions are useful and do not imped its use as a Reference Model.

### Built-in Bootloader
An undocumented feature of Spike is that it will execute a simple "boot loader" starting at address 0x1000.
This cannot be disabled without modification of the Spike source code.
Fortunately, the inclusion of this "boot loader" is innocuous and for the most part can be ignored,
although it does mean that _your_ test-program cannot start at 0x1000.

### Use of ABI Naming and Calling Conventions
An Application Binary Interface provides, amoung other things, a set of conventions for naming and using CSRs.
While these may be both useful and familiar to software developers, for the purposes of verifying RTL implementations, these conventions have no real utility,
and may actually create coverage holes in verification.
Consider the GPR x2: there is nothing magical about x2 that makes it a stack pointer - any RISC-V GPR, with the exception of x0, can be a stack pointer, and x2 can used for any legal purpose as per the ISA, not just as a stack pointer.
The typical instructions used to manage a stack are `auipc`, `lw`, `sw` and `addi`.
If we always use GPRs as per the ABI in our test-programs, we might never use x2 for any other instruction.
As verification engineers we must be aware that our goal is to verify the implementation of the core against the ISA, not the ABI.
Fortunately, Spike has no such restrictions, but it will always refer to GPRs using the ABI naming convention.

### Simulation Termination
Programs written for Spike simulations are typically ended by creating an infinite loop, so that the program doesn’t wander into undefined instructions.
In CORE-V-VERIF it is considered good practise to end the test-programs with a wait-for-interrupt (wfi) instruction.
This will eventually halt the core's execution pipeline and idle the instruction-fetch and load/store memory interfaces after all outstanding memory operations are completed and all pending+enabled interrupts and debug requests are serviced.
<!--- TODO: explain why this is desirable --->

### Signatures
Spike has a signature mechanism to write the contents of a block of memory to a file upon completion.
The idea here is that a test-program writes out the signature block with a series of words that are only correct if the program ran properly.
<!--- TODO: explain the impact of the signature block in a linker control script (.data section is delimited by begin_signature: and end_signature: labels.) --->
Running Spike with the command below writes the values in the signature block to a file named example.signature.output, 4 bytes per line in hexadecimal.
The user can compare this file with an expected output to determine whether the program ran correctly.
```
$ spike +signature=example.signature.output +signature-granularity=4 example

```

```{note}
In general, CORE-V-VERIF does not make use of the signatures to determine
the pass/fail status of a test-program. The exception to this is the RISC-V
Architecture Compliance test-suite since the Compliance framework relies on
a set of previously generated, self checking test-programs which dump signatures.
```

### Host Target Interface
Spike supports a console emulator called the host target interface (HTIF) which has a number of useful features when using Spike as a simulator.
The HTIF has been called [an experiment that got out of the lab](https://github.com/riscv-software-src/riscv-isa-sim/issues/364#issuecomment-607657754),
and although it is not a RISC-V standard, it is in such widespread use within the RISC-V community that CORE-V-VERIF has moved to partially support it.

The most commonly used feature of the HTIF is a mechanism that a program can use to signal completion.
To do so, the program must declare an 8-byte .dword at a label called `tohost`.
When Spike "sees" a write of 1 to this address it causes the program to terminate successfully.
A write of 3 causes it to print \*\*\* FAILED \*\*\* and terminate.

The address of `tohost` doesn’t matter; Spike detects a write to an address with a label of this name in the symbol table (which is in the ELF file).

A write of any even number to the HTIF triggers a system call, with the number interpreted as a pointer to an array in memory containing the system call number and arguments.
For example, system call number 64 is sys_write, which takes three arguments: a file descriptor, a pointer to a string, and the length of the string.
File descriptors of 0, 1, and 2 correspond to stdin, stdout, and stderr, respectively.
Spike supports other commands such as system calls through the HTIF, but they are poorly documented.

```{important}
Test-programs written for CORE-V-VERIF should use the HTIF with caution.
Doing so may make the environment unstable and will make it difficult to support other Reference Models.
```

### Proxy Kernel and GDB
Spike uses another program called proxy kernel (pk) to handle system calls using the host operating system.
Spike also has the ability to interface with gdb through OpenOCD for debugging.
CORE-V-VERIF does not support either of these features.

## Running a Simulation with Spike
Assuming you have already installed GCC and Spike, type the following:
```
$ cd ReferenceModels/Spike/quickstart
$ ls
eg.S  link.ld  Makefile  README.md
```
The Makefile has a target that first deletes any previously generated files and then compiles and links `eg.S` for both RV32I and RV64I architectures.
The two input files for this example are `eg.S`, a (very) simple RISC-V assembly program and `link.ld`, an equally simple linker control script.
We will have much more to say about both of these files, but for now, you can compile and run them with the `make all` command.
You should see something like this:
<details>

<summary>Output of 'make all' command</summary>

```
*******************************************************************************
clean_all: remove all generated files, no exceptions
*******************************************************************************
rm -rf example??.* *.obj *.readelf

*******************************************************************************
example32: compile eg.S for an RV32I machine
*******************************************************************************
riscv32-unknown-elf-gcc     -o example32.elf -march=rv32i -mabi=ilp32 -nostartfiles -mcmodel=medany -Tlink.ld eg.S
riscv32-unknown-elf-objdump -D example32.elf > example32.objdump
riscv32-unknown-elf-readelf -a example32.elf > example32.readelf

*******************************************************************************
example64: compile eg.S for an RV64I machine
*******************************************************************************
riscv32-unknown-elf-gcc     -o example64.elf -march=rv64i -mabi=lp64 -nostartfiles -mcmodel=medany -Tlink.ld eg.S
riscv32-unknown-elf-objdump -D example64.elf > example64.objdump
riscv32-unknown-elf-readelf -a example64.elf > example64.readelf

*******************************************************************************
spike32: run example32
*******************************************************************************
spike --isa=rv32i -l -m0x00004000:0x410000 example32.elf
core   0: 0x00001000 (0x00000297) auipc   t0, 0x0
core   0: 0x00001004 (0x02028593) addi    a1, t0, 32
core   0: 0x00001008 (0xf1402573) csrr    a0, mhartid
core   0: 0x0000100c (0x0182a283) lw      t0, 24(t0)
core   0: 0x00001010 (0x00028067) jr      t0
core   0: >>>>  $xrv32i2p1
core   0: 0x00008000 (0x02a00513) li      a0, 42
core   0: >>>>  write_to_host
core   0: 0x00008004 (0x00000317) auipc   t1, 0x0
core   0: 0x00008008 (0x01430313) addi    t1, t1, 20
core   0: 0x0000800c (0x00100293) li      t0, 1
core   0: 0x00008010 (0x00532023) sw      t0, 0(t1)
core   0: 0x00008014 (0x10500073) wfi

*******************************************************************************
spike64: run example64
*******************************************************************************
spike --isa=rv64i -l -m0x00004000:0x410000 example64.elf
core   0: 0x0000000000001000 (0x00000297) auipc   t0, 0x0
core   0: 0x0000000000001004 (0x02028593) addi    a1, t0, 32
core   0: 0x0000000000001008 (0xf1402573) csrr    a0, mhartid
core   0: 0x000000000000100c (0x0182b283) ld      t0, 24(t0)
core   0: 0x0000000000001010 (0x00028067) jr      t0
core   0: >>>>  $xrv64i2p1
core   0: 0x0000000000004000 (0x02a00513) li      a0, 42
core   0: >>>>  write_to_host
core   0: 0x0000000000008004 (0x00000317) auipc   t1, 0x0
core   0: 0x0000000000008008 (0x01430313) addi    t1, t1, 20
core   0: 0x000000000000800c (0x00100293) li      t0, 1
core   0: 0x0000000000008010 (0x00532023) sw      t0, 0(t1)
core   0: 0x0000000000008014 (0x10500073) wfi
```
</details>

<br>
Take a look at the `Makefile` plus the input `eg.S` and `link.ld` files, as well as the generated `*.readelf` and `*.objdump` files.
We will review each of these.

### Spike simulation of eg.S
Consider the command-line invoked by the Makefile to simulate the RV32I version of the test-program:
```
$ spike --isa=rv32i -l -m0x00004000:0x410000 example32.elf
```
The input to Spike is `example32.elf`, compiled from `eg.S` by GCC.
We will look into this in more detail later.

A list of Spike command-line options and their meaning can be obtained by invoking `spike -h` on the command-line.
The options used here are:
- **--isa** : be careful to ensure this matches the machine architecture of the core you are working with and the `march` option for GCC.
- **-l** : writes an execution log to stdout.
- **-m\<base:size\>** : provides a memory region starting at `base` of `size` bytes.
You can specify multiple memory regions.

If you want Spike to dump a log to an output file,
you must specify both `-l` and `--log=<_filename_>` command-line options:
```
$ spike --isa=rv32i -l --log=my.spike.log <...other args...>
```

Below is the execution log emitted by Spike:
```
core   0: 0x00001000 (0x00000297) auipc   t0, 0x0
core   0: 0x00001004 (0x02028593) addi    a1, t0, 32
core   0: 0x00001008 (0xf1402573) csrr    a0, mhartid
core   0: 0x0000100c (0x0182a283) lw      t0, 24(t0)
core   0: 0x00001010 (0x00028067) jr      t0
core   0: >>>>  $xrv32i2p1
core   0: 0x00008000 (0x02a00513) li      a0, 42
core   0: >>>>  write_to_host
core   0: 0x00008004 (0x00000317) auipc   t1, 0x0
core   0: 0x00008008 (0x01430313) addi    t1, t1, 20
core   0: 0x0000800c (0x00100293) li      t0, 1
core   0: 0x00008010 (0x00532023) sw      t0, 0(t1)
core   0: 0x00008014 (0x10500073) wfi
```
If you looked at `eg.S` you may be confused to see the first instruction executed is `auipc t0, 0x0` and not `li a0 42`.
This is the first instruction of Spike's boot loader that was mentioned previously.
The last instruction of the boot loader is an unconditional jump to the start of the test-program in `eg.S`.
As an exercise, convince yourself that t0 stores 0x8000.

You may be wondering why the test-program starts at that specific address; and why a non-default memory region has been defined.
We will look at this a bit later...

## Running Spike Interactively
To simulate in interactive debug mode, run Spike with -d.
```
$ spike -d --isa=rv32i -m0x00004000:0x410000 example32.elf
```
Press enter to advance through the program one line at a time.
To see the contents of integer register t0 on hart 0, type:
```
: reg 0 t0
```
Spike uses ABI names for GPRs, so the following will **not** work even though t0 is the ABI name for x5:
```
: reg 0 x5
```
This also works for CSRs:
```
: reg 0 mstatus
```
Again, the physical address will **not** work:
```
: reg 0 0x300
```
To read the contents of physical memory at address 0x8000, type:
```
: mem 0 0x8000
```
To see the contents of a single- or double-precision floating-point register, replace reg with `fregs` or `fregd`.
Of course, in this example, Spike isn't simulating a machine that supports floating point, so a read of a floating point register returns 0x0, which Spike reports as "NaN".
```
: fregs 0 ft0
```

The commands below illustrate more of Spike’s capabilities.
The `until` statement runs until a condition is satisfied on a given hart.
The `while` statement runs as long as a condition is satisfied.
`run` runs indefinitely, printing the PC and instruction as it goes.
`rs` runs silently, without printing.
At any point (even without the -d flag), pressing Ctrl-c pauses the simulation and reenters interactive debug mode.
Pressing `q` ends the simulation.
```
: until pc 0 0x8008
: until reg 0 a0 2a
: until mem 0 8020 1
: while mem 0 8020 deadbeef
: run
: <Ctrl-c>
: q
```

```{note}
The `mem` commands above won't work exactly as shown here as `eg.S` does not write to memory.
```

## Walking Through the Quickstart Example
Recall that in the GCC command line, two files are passed as input to the compiler.
We now look at these files in detail:
### The Assembly Source File (eg.S)
Below is the source code for the example RISC-V assembly language program you just simulated with Spike:

```
.section .text
.globl rvtest_entry_point
rvtest_entry_point:
  li a0, 42

write_to_host:
    la t1, tohost # Load address of tohost label into t1
    li t0, 1      # 1 for success, 3 for failure
    sw t0, 0(t1)  # Send success code

test_program_end:
    wfi

.section .spike_labels
tohost:
    .dword 0
fromhost:
    .dword 0
```
Symbols starting with a dot are assembler directives.  The first two are:
- `.section .text` defines the start of a text section (program code)
- `.globl rvtest_entry_point` the linker expects a global label at the start of the program, and `rvtest_entry_point` is a popular name for this symbol.

The program starts by loading decimal 42 into register a0.
The code immediately following the `write_to_host` label writes 1 to the address defined by the `tohost` label.
Lastly, program ends with an `wfi` (wait for interrupt).

At the end of the program we define a second section called `.spike_labels` and allocate a memory address labelled `tohost` and another labelled `fromhost` to that section.
These labels are meaningless to a RISC-V hardware implementation, but as will be explained later, are recognized by Spike.

### The Linker Control Script (link.ld)
The Makefile assembles the program with the following command line, which will be fully explained later.
```
$ riscv64-unknown-elf-gcc -o example32.elf -march=rv32i -mabi=ilp32 -nostartfiles -mcmodel=medany -Tlink.ld eg.S
```
The `-Tlink.ld` command-line option instructed GCC to use `link.ld` as the Linker Control Script.
This file contains the information required to map the symbols used in the Assembly source file(s) to physical addresses.
```
OUTPUT_ARCH( "riscv" )
ENTRY(rvtest_entry_point)

MEMORY
{
  imem (rx!wai) : ORIGIN = 0x00008000, LENGTH = 0x400000
  mmio (rw!xai) : ORIGIN = 0x00004000, LENGTH = 0x100
}

SECTIONS
{
  .text : {
    *(.text)
  } > imem

  .spike_labels : ALIGN(0x1000)
  {
    *(.tohost)
  } > mmio

  _end = .;
}
```
**OUTPUT_ARCH** should be self explainatory.
**ENTRY** is the first instruction to execute in a program.
Note that it references the symbol `rvtest_entry_point`, which is the first global label defined at the top of the first text section in the test-program.

The **MEMORY** section is optional and could be omitted for this simple example.
We include it here because the MEMORY section is used in almost all CORE-V-VERIF linker control scripts and it is a convinient method for expressing how memory is being used by the test-program.
Here we have defined two blocks of memory:
- **imem** is the Instuction Memory.  It starts at 0x8000 and ends at 0x407FFF. This region is read-able and executable, but not write-able, allocated or initialized.
- **mmio** or Memory Mapped I/O starts at 0x4000 and ends are 0x40FF. This region is read-able and write-able, but NOT executable, allocated or initialized.

**SECTIONS** is a manditory part of the script which defines named blocks of data, mapping symbols to blocks of memory.
Some sections are defined by [POSIX](https://en.wikipedia.org/wiki/POSIX) convention.
For example, `.text` is where the machine code for the program is loaded.
Our linker control script follows this convention by allocating all symbols in the `.text` section to the Instruction RAM (imem).
The script also allocates all symbols in the `.spike_labels` section to the Memory Mapped Input/Output (mmio) region.
Note that the memory region names (`imem` and `mmio`) have no meaning other than to define two distinct regions
(although the names were deliberately chosen with human-readability in mind).

### Defining Memory
In order to execute successfully, a test-program must be compiled to match the memory architecture of the core it will run on,
and the starting address of the test-program must match the starting address (or reset vector) of the core.

#### Test-Program Start Address
As we have seen, defining the starting address of the compiled test-program is determined by the linker control script.
In the script above, the start address resolves to 0x8000 because the first text section is assigned to the imem memory region whose origin is set to 0x8000.
In the absence of a memory region, the start address of the first text section should be explicitly defined:
```
SECTIONS
{
  . = 0x8000
  .text : {
    *(.text)
  }
...
  /* remainder of SECTIONS */
}
```

If the linker script is not specified, GCC will default to starting the program at 0x10078.

#### Spike's Memory Allocation
In our linker control script, two memory regions are defined: **mmio** from 0x4000 to 0x40FF, and **imem** from 0x8000 to 0x407FFF.
Spike's default start address is 0x80000000, so we must define the simulation's memory map as a command-line option:
```
$ spike --isa=rv32i -l -m0x00004000:0x410000 example32.elf
```

The command-line option `-m0x00004000:0x410000` defines a memory region for Spike that encompasses both the mmio and imem address range.
We could have defined two memory regions as follows:
```
$ spike --isa=rv32i -l -m0x4000:0x1000,0x8000:0x410000 example32.elf
```
Note that the sizes of the memory regions defined with the `-m` option must align to 4KiB pages.

Recall that Spike starts by executing a simple boot loader code segment starting at
address 0x1000 that ultimately jumps to the start address of the test-program
(also known as the **reset vector**) at address 0x1018.
If specified in the ELF file, Spike loads the start address from the ELF to memory at address 0x1018
(which is where the boot loader expects to find it).

The `--pc=<addr>` command line argument changes the value of the start address,
overriding both the default and the ELF.

`-m<base:size>` provides a memory region starting at `base` of `size` bytes.
You can specify multiple memory regions, type `spike -h` for more info.

If the linker control script (link.ld) defines a memory region that fits within Spike's default memory region(s)
**_and_** a start address that matches Spike's default start address,
then it is not necessary to define either the start address or memory regions on the command line
(that is, the `--pc` and `-m` agrs are not necessary).
The linker control script below is an example:
```
 1  OUTPUT_ARCH( "riscv" )
 2  ENTRY(rvtest_entry_point)
 3
 4  SECTIONS
 5  {
 6    . = 0x80000000;
 7    .text : {
 8      *(.text.init)
 9      *(.text)
10    }
11
12    . = ALIGN(0x1000);
13    .tohost : {
14      *(.tohost)
15    }
16
17    _end = .;
18  }
```

```{note}
It is recommended to _always_ define memory regions for Spike as the default memory regions are not documented,
and there is always the risk that they may change from one release to the next.
```

For example, consider the following changes to line 6 from the above linker control script:
```
 4  SECTIONS
 5  {
 6    . = 0x00004000; /* non-default start */
 7    .text : {
```
This changes the start address of the program to be 0x4000, and defines the .tohost label to start on the next 4KiB boundary.
Similating a program linked with the above script with Spike requires explicit defintion of the memory:
```
$ spike --isa=rv32i -l -m0x00004000:0x410000 my.elf
core   0: 0x00001000 (0x00000297) auipc   t0, 0x0
core   0: 0x00001004 (0x02028593) addi    a1, t0, 32
core   0: 0x00001008 (0xf1402573) csrr    a0, mhartid
core   0: 0x0000100c (0x0182a283) lw      t0, 24(t0)
core   0: 0x00001010 (0x00028067) jr      t0
core   0: >>>>  $xrv32i2p1
core   0: 0x00004000 (0x02a00513) li      a0, 42
core   0: >>>>  write_to_host
core   0: 0x00004004 (0x00001317) auipc   t1, 0x1
core   0: 0x00004008 (0xffc30313) addi    t1, t1, -4
core   0: 0x0000400c (0x00100293) li      t0, 1
core   0: 0x00004010 (0x00532023) sw      t0, 0(t1)
core   0: 0x00004014 (0x10500073) wfi
```
See how Spike starts executing code from the boot loader at 0x1000 which initializes a1 to 0x1020 and a0 with the hard id.
Next, the boot loader at address 0x100c reads from memory at 0x1018 to find the start address (0x4000 in this case).

### The ELF File
The `-o example32.elf` command-line option instructed GCC to write its output to `example32.elf`.
Let's take a look at that file:
```
$ file example32.elf
example32.elf: ELF 32-bit LSB executable, UCB RISC-V, soft-float ABI, version 1 (SYSV), statically linked, not stripped
```
So the output of GCC is _not_ a raw machine code file, but something called an ELF or Extendable and Linkable Format file.
An ELF is a binary file (so, not human readable) which _does_ contain the executable machine code,
plus representations of the various symbols used in the program's source code.
Spike is able to read the ELF file directly and humans can use the `readelf` command to generate a human readable version of the ELF file:
```
$ riscv64-unknown-elf-readelf -a example32.elf > example32.readelf
```
A quick tutorial for using 'readelf' to parse Executable and Linkable Format (ELF) files can be found [here](https://www.geeksforgeeks.org/readelf-command-in-linux-with-examples).

<details>

<summary>Click to view example32.readelf</summary>

```
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           RISC-V
  Version:                           0x1
  Entry point address:               0x8000
  Start of program headers:          52 (bytes into file)
  Start of section headers:          8560 (bytes into file)
  Flags:                             0x0
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         2
  Size of section headers:           40 (bytes)
  Number of section headers:         7
  Section header string table index: 6

Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .text             PROGBITS        00008000 001000 000018 00  AX  0   0  4
  [ 2] .spike_labels     PROGBITS        00004000 002000 000010 00      0   0 4096
  [ 3] .riscv.attributes RISCV_ATTRIBUTE 00000000 002010 00001e 00      0   0  1
  [ 4] .symtab           SYMTAB          00000000 002030 0000b0 10      5   9  4
  [ 5] .strtab           STRTAB          00000000 0020e0 00004d 00      0   0  1
  [ 6] .shstrtab         STRTAB          00000000 00212d 000041 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  D (mbind), p (processor specific)

There are no section groups in this file.

Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  RISCV_ATTRIBUT 0x002010 0x00000000 0x00000000 0x0001e 0x00000 R   0x1
  LOAD           0x001000 0x00008000 0x00008000 0x00018 0x00018 R E 0x1000

 Section to Segment mapping:
  Segment Sections...
   00     .riscv.attributes 
   01     .text 

There is no dynamic section in this file.

There are no relocations in this file.

The decoding of unwind sections for machine type RISC-V is not currently supported.

Symbol table '.symtab' contains 11 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 00008000     0 SECTION LOCAL  DEFAULT    1 .text
     2: 00004000     0 SECTION LOCAL  DEFAULT    2 .spike_labels
     3: 00000000     0 SECTION LOCAL  DEFAULT    3 .riscv.attributes
     4: 00000000     0 FILE    LOCAL  DEFAULT  ABS ccLjYAme.o
     5: 00008000     0 NOTYPE  LOCAL  DEFAULT    1 $xrv32i2p1
     6: 00008004     0 NOTYPE  LOCAL  DEFAULT    1 write_to_host
     7: 00004000     0 NOTYPE  LOCAL  DEFAULT    2 tohost
     8: 00004008     0 NOTYPE  LOCAL  DEFAULT    2 fromhost
     9: 00008000     0 NOTYPE  GLOBAL DEFAULT    1 rvtest_entry_point
    10: 00004010     0 NOTYPE  GLOBAL DEFAULT    1 _end

No version information found in this file.
Attribute Section: riscv
File Attributes
  Tag_RISCV_arch: "rv32i2p1"
  Tag_RISCV_priv_spec: 1
  Tag_RISCV_priv_spec_minor: 11
```
</details>

<br>
It is beyond the scope of this document to detail the contents of the ELF file, but a few things are worthy of note:

- In the **ELF Header** section, observe that the ELF file shows the program uses 32-bit code (indicated by ELF32) in little-endian format,
starting at 0x8000 as indicated by entry point address.
- In the **Section Headers** section, note that the `.spike_labels` section starts at address 0x4000,
and the `.text` section starts at address 0x8000 as determined by the linker control script.
The offset column directly adjacent to the address column indicates the offset of the label in the ELF file itself,
not the address of the label in the machine code.
- In **File Attributes** it indicates that the code requires at least RV32I version 2.1 (indicated by Tag_RISCV_arch: "rv32i2p1").
